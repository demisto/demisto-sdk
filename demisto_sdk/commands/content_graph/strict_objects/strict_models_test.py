"""
Tests for strict models to ensure they accept SDK-generated fields.
"""
import pytest

from demisto_sdk.commands.content_graph.strict_objects.pack_meta_data import (
    StrictPackMetadata,
)
from demisto_sdk.commands.content_graph.strict_objects.pre_process_rule import (
    StrictPreProcessRule,
)


class TestStrictPackMetadata:
    """Tests for StrictPackMetadata model."""

    def test_accepts_first_created_field(self):
        """
        Given:
            - A pack metadata dict with 'firstCreated' field (generated by demisto-sdk init)
        When:
            - Creating a StrictPackMetadata instance
        Then:
            - The model accepts the input without validation errors
            - The 'created' field is populated with the 'firstCreated' value
        """
        metadata_dict = {
            "name": "TestPack",
            "author": "Test Author",
            "support": "xsoar",
            "firstCreated": "2024-01-01T00:00:00Z",
            "currentVersion": "1.0.0",
            "serverMinVersion": "6.0.0",
        }

        # Should not raise ValidationError
        pack_metadata = StrictPackMetadata(**metadata_dict)

        # Verify the created field is populated via the alias
        assert pack_metadata.created == "2024-01-01T00:00:00Z"

    def test_accepts_created_field_directly(self):
        """
        Given:
            - A pack metadata dict with 'created' field (not using alias)
        When:
            - Creating a StrictPackMetadata instance
        Then:
            - With an alias defined, Pydantic expects the alias name in input
            - This test verifies that using the field name directly is rejected as expected
        """
        from pydantic import ValidationError

        metadata_dict = {
            "name": "TestPack",
            "author": "Test Author",
            "support": "xsoar",
            "created": "2024-01-01T00:00:00Z",  # Using field name instead of alias
            "currentVersion": "1.0.0",
            "serverMinVersion": "6.0.0",
        }

        # When using alias, Pydantic expects the alias name in input by default
        # This is expected behavior - the field name "created" is treated as extra
        with pytest.raises(ValidationError) as exc_info:
            StrictPackMetadata(**metadata_dict)

        errors = exc_info.value.errors()
        assert len(errors) == 1
        assert errors[0]["type"] == "value_error.extra"
        assert "created" in str(errors[0])

    def test_rejects_extra_fields(self):
        """
        Given:
            - A pack metadata dict with an unknown extra field
        When:
            - Creating a StrictPackMetadata instance
        Then:
            - The model raises a validation error for the extra field
        """
        from pydantic import ValidationError

        metadata_dict = {
            "name": "TestPack",
            "author": "Test Author",
            "support": "xsoar",
            "currentVersion": "1.0.0",
            "serverMinVersion": "6.0.0",
            "unknownExtraField": "some value",
        }

        # Should raise ValidationError for extra field
        with pytest.raises(ValidationError) as exc_info:
            StrictPackMetadata(**metadata_dict)

        errors = exc_info.value.errors()
        assert len(errors) == 1
        assert errors[0]["type"] == "value_error.extra"
        assert "unknownExtraField" in str(errors[0])


class TestStrictPreProcessRule:
    """Tests for StrictPreProcessRule model."""

    @staticmethod
    def get_base_preprocess_rule_dict():
        """Helper to create a minimal valid PreProcessRule dict."""
        return {
            "action": "drop",
            "enabled": True,
            "existingEventsFilters": [],
            "fromVersion": "6.0.0",
            "id": "test-rule-id",
            "index": 0,
            "itemVersion": "1.0.0",
            "linkTo": "",
            "locked": False,
            "name": "Test Rule",
            "description": "Test Description",
            "newEventFilters": [],
            "packID": "TestPack",
            "readyExistingEventsFilters": [],
            "readyNewEventFilters": [],
            "scriptName": "TestScript",
            "searchClosed": False,
            "system": False,
            "toServerVersion": "",
            "version": 1,
        }

    def test_accepts_script_id_field(self):
        """
        Given:
            - A PreProcessRule dict with 'scriptId' field
        When:
            - Creating a StrictPreProcessRule instance
        Then:
            - The model accepts the input without validation errors
        """
        rule_dict = self.get_base_preprocess_rule_dict()
        rule_dict["scriptId"] = "test-script-id"

        # Should not raise ValidationError
        rule = StrictPreProcessRule(**rule_dict)
        assert rule.script_name == "TestScript"

    def test_accepts_legacy_script_id_casing(self):
        """
        Given:
            - A PreProcessRule dict with legacy 'scriptID' field (capital D)
        When:
            - Creating a StrictPreProcessRule instance
        Then:
            - The model accepts the input without validation errors
            - The legacy field is mapped to the canonical form
        """
        rule_dict = self.get_base_preprocess_rule_dict()
        rule_dict["scriptID"] = "test-script-id-legacy"

        # Should not raise ValidationError
        rule = StrictPreProcessRule(**rule_dict)
        assert rule.script_name == "TestScript"

    def test_script_id_with_marketplace_suffix(self):
        """
        Given:
            - A PreProcessRule dict with marketplace-specific 'scriptId:xsoar' field
        When:
            - Creating a StrictPreProcessRule instance
        Then:
            - The model accepts the input without validation errors
        """
        rule_dict = self.get_base_preprocess_rule_dict()
        rule_dict["scriptId:xsoar"] = "test-script-id-xsoar"

        # Should not raise ValidationError
        rule = StrictPreProcessRule(**rule_dict)
        assert rule.script_name == "TestScript"

    def test_rejects_extra_fields(self):
        """
        Given:
            - A PreProcessRule dict with an unknown extra field
        When:
            - Creating a StrictPreProcessRule instance
        Then:
            - The model raises a validation error for the extra field
        """
        from pydantic import ValidationError

        rule_dict = self.get_base_preprocess_rule_dict()
        rule_dict["unknownExtraField"] = "some value"

        # Should raise ValidationError for extra field
        with pytest.raises(ValidationError) as exc_info:
            StrictPreProcessRule(**rule_dict)

        errors = exc_info.value.errors()
        assert len(errors) == 1
        assert errors[0]["type"] == "value_error.extra"
        assert "unknownExtraField" in str(errors[0])
